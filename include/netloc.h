#ifndef _WIP_H
#define _WIP_H
#include "utils/uthash.h"
#include "utils/utarray.h"

#include <hwloc.h>

//#include "netloc-utils.h"

// TODO scotch int
#define NETLOC_INT int

enum {
    NETLOC_SUCCESS         =  0, /** Success */
    /* Errors */
    NETLOC_ERROR,              /** General condition */
    NETLOC_ERROR_BADMACHINE,   /** Bad machine */
    NETLOC_ERROR_NODENOTFOUND, /** Node not found */
    NETLOC_ALRD_IN_RESTRICT,   /** Node already in restriction */
    NETLOC_ERROR_NOENT,        /** URI is invalid, no such entry */
};

/**
 * Enumerated type for the various types of supported topologies
 */
typedef enum {
    NETLOC_TOPOLOGY_TYPE_INVALID  = 0,  /**< Invalid */
    NETLOC_TOPOLOGY_TYPE_RANDOM   = 1,  /**< Random */
    NETLOC_TOPOLOGY_TYPE_RING     = 2,  /**< Ring */
    NETLOC_TOPOLOGY_TYPE_GRID     = 3,  /**< Grid */
    NETLOC_TOPOLOGY_TYPE_ALL2ALL  = 4,  /**< All2All */
    NETLOC_TOPOLOGY_TYPE_TREE     = 5,  /**< Tree */
    NETLOC_TOPOLOGY_TYPE_TORUS    = 6,  /**< Torus */
} netloc_topology_type_t;


/* Pre declarations to avoid inter dependency problems */
/** \cond IGNORE */
struct netloc_machine_t;
typedef struct netloc_machine_t netloc_machine_t;
struct netloc_arch_t;
typedef struct netloc_arch_t netloc_arch_t;
struct netloc_node_t;
typedef struct netloc_node_t netloc_node_t;
struct netloc_filter_t;
typedef struct netloc_filter_t netloc_filter_t;
/** \endcond */

/******************************************************************************/
/* PUBLIC API */
/******************************************************************************/

/** \brief Load an XML topology file previously generated by netloc tool.
 *
 * \param[out] pmachine The pointer to the machine that be filled.
 * \param[int] path The path to the machine file.
 *
 * \return 0 on success.
 */
int netloc_machine_load(netloc_machine_t **pmachine, char *path);

/** \brief Save a machine into an XML file.
 *
 * \param[in] machine The machine to save.
 * \param[in] path The path where to save to the machine file.
 *
 * \return 0 on success.
 */
int netloc_machine_save(netloc_machine_t *machine, char *path);

/** \brief Get the description of the topology of a given machine
 *
 * \param[in] machine The machine.
 * \param[in] filter A filter for selecting levels and partition in the
 *              topology... NULL for all.
 * \param[out] nlevels The number of sub-topologies in the topology.
 * \param[out] ncoords The number of coordinates in the topology.
 * \param[out] dims The dimension valeu for each sub-topology.
 * \param[out] types The type of each sub-topology.
 * \param[out] levelidx The index of the levels.
 * \param[out] costs The list of the cost for each hop.
 *
 * \note For now filter is not handled
 *
 * \return 0 on success.
 */
int netloc_topology_get(netloc_machine_t *machine, netloc_filter_t *filter,
        int *nlevels, int *ncoords, int **dims, netloc_topology_type_t **types,
        int **levelidx,  int **costs);

/** \brief Try to find a node with hostname matching a given name.
 *
 * \param[in] machine The machine.
 * \param[in] name The name to match.
 * \param[out] node The found node.
 *
 * \return 0 on success.
 */
int netloc_node_find(netloc_machine_t *machine, char *name, netloc_node_t **node);

/** \brief Find the node where this function is call from
 *
 * \param[in] machine The machine.
 * \param[out] node The found node.
 *
 * \return 0 on success.
 */
int netloc_node_current(netloc_machine_t *machine, netloc_node_t **node);

/** \brief Find the node where this function is call from
 *
 * \param[in] machine The machine.
 * \param[in] filter A filter for selecting levels and partition in the
 *              topology... NULL for all.
 * \param[in] node The found node.
 * \param[out] coords The list of coords.
 *
 * \note For now filter is not handled
 *
 * \return 0 on success.
 */
int netloc_node_get_coords(netloc_machine_t *machine, netloc_filter_t *filter,
        netloc_node_t *node, int *coords);

/** \brief Get the partition number of a given node.
 *
 * \param[in] machine The machine.
 * \param[in] filter A filter for selecting levels and partition in the
 *              topology... NULL for all.
 * \param[in] node The found node.
 * \param[out] partition The partition index.
 *
 * \note For now filter is not handled
 *
 * \return 0 on success.
 */
int netloc_node_get_partition(netloc_machine_t *machine, netloc_filter_t *filter,
        netloc_node_t *node, int *partition);

/** \brief Add a given node to a restriction of a machine (a subset of nodes).
 *
 * \param[in,out] machine The machine.
 * \param[in] node The node to add.
 *
 * \note When the machine will be saved, the restriction will be save with it.
 *
 * \return 0 on success.
 */
int netloc_restriction_add_node(netloc_machine_t *machine, netloc_node_t *node);
#endif
